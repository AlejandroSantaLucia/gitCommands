<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Comandos y uso Git</title>
    <link rel="stylesheet" href="css/estilos.css">
</head>
<body>
    <h6 class="fixed" id="changeWeb">Cambiar a versión nocturna</h6>
    <h1>Comandos más usados:</h1>
    <ul>
        <li><b>git init:</b> se usa para iniciar un nuevo repositorio de Git</li>
        <li><b>git config --global user.name "Nombre":</b> Configura nombre usuario</li>
        <li><b>git config --global user.email "email":</b> Configura email usuario</li>
        <li><b>git status: </b>Muestra el estado de actual de los archivos ubicados en el área de staging</li>
        <li><b>git add nombreArhivo.extension: </b>Agrega al área de staging el o los archivos.</li>
        <li><b>git commit -m "Descripcion commit": </b>Agrega los cambios a la BD del repositorio de git</li>
        <li><b>git commit -am "Descripción commit": </b>Nos ahorra el tener que utilizar <b>git commit .</b>, este comando solo es válido para archivos que ya existen en el repositorio, no afectará a archivos nuevos que no hayan sido agregados con add</li>
        <li><b>git commit:</b> Abrirá el editor Vim para poder agregar un comentario, siempre es obligatorio agregar un comentario para el commit. Para poder editar el comit usar "ESC  i". Para guardar cambios ESC + SHIFT + Z Z</li>
        <li><b>git log: </b>Muestra el historial detallado con commit e id, de todos los commits en dicho repositorio</li>
        <li><b>Git log repotenciado:</b> Para tener una visualización más gráfica de tu historial en un repositorio, puedes usar el comando <b>git log --all -decorate- oneline</b> con esto, podrás ver el historial de cambios y ramas de forma más gráfica. <br><img src="img/git_log_all_graph_decorate.png" alt="ver log de commits y ramas historicas en un repositorio"><br></li>
        <li><b>git diff: </b>Permite ver las diferencias entre el staging y nuestro archivo en local. tiene las variaciones <b>git diff id1 id2</b> donde se comparan dos versiones según los id del commit seleccionado. y <b>git diff --stat</b> donde ves las diferencias más resumidas.</li>
        <li><b>git show: </b>Se utiliza para ver el commit y la rama en el que te encuentras actualmente.</li>
    </ul>

    <h1>Comando de consola útiles</h1>
    <p>Esta sección es un extra, no tiene que ver directamente con Git, pero puede apoyar de una u otra manera tu repositorios.</p>
    <ul>
        <li><b>Crear un alias:</b> para resumir comandos que sean muy extensos, se puede utilizar el comando <b>alias nombreNuevoComando="Comando a convertir"</b> de esta manera, podemos usar una palabra más fácil de recordar para nosotros. <br><b>Ejemplo:</b> alias arbolito="git log --all --graph --decorate --oneline"</li>
    </ul>

    <h1>Comandos importantes:</h1>
    <p>Estos comandos se separan ya que tienen funciones muy importantes.</p>
    <ul>
        <li><b>git reset idCommit --hard/soft</b> Este comando se encarga de regresar a una versión especificada. Se debe tener cuidado con este comando, ya que borrará absolutamente todos los cambios realizados despues de dicho commit. existen dos variastes para el mismo. <b>--hard</b> hará que regrese por completo todo a la versión elegida, perdiendo incluso, los cambios en staging. <b>--soft</b> cumple el mismo rol, pero mantiene los cambios en staging para su posterior commit. </li>
        <li><b>git reset HEAD (Me encanta XD): </b>Regresa todos los cambios en staging como unstaged. Es decir, revierte el git add.</li>
        <li><b>git checkout idCommit archivo.extension:</b> Obtiene la versión especificada de dicho archivo. PERO, no elimina sus versiones posteriores. La versión obtenida se tomará como untracked y podrá ser agregada al staging para realizar commit y crear una nueva versión.</li>
        <li><b>git rm --cached:</b> Elimina los archivos del área de Staging y del próximo commit pero los mantiene en nuestro disco duro.</li>
        <li><b>git rm --force:</b> Elimina los archivos del área de Staging y de nuestro disco duro.</li>
        <ul><li><p>Para mayor información hasta acá leer: <a href="https://platzi.com/clases/1557-git-github/23295-git-reset-vs-git-rm/">Este post de Platzi (necesitas tener suscripción).</a></p></li></ul>
    </ul>
    <br>

    <h1>Comandos en ramas</h1>
    <p>Estos son los comandos aplicados para manejarse entre ramas, crear nuevas ramas, etc.</p>
    <ul>
        <li><b>git branch nameBranch:</b> Se utiliza para crear una nueva rama.</li>
        <li><b>git checkout nameBranch</b> Se utiliza para dirigirse hacia la rama elegida.</li>
        <li><b>git merge nombreRama: </b> Este comando es <b>súper importante</b>, se utiliza cuando quieres unir los cambios entre 2 ramas. <br> Cuando tienes los cambios de una nueva que creaste y ya les hiciste commit, puedes hacer un merge para fusionarlos con tu rama de master. El proceso puede ser MASTER -> RAMA_NUEVA o RAMA_NUEVA -> MASTER. Cuando quieres dejar todo en master para tener todo en la rama principal, debe usar la segunda opción.</li><br>
        <ul>
            <li><b>Conflictos: </b>En GIT, los conflictos aparecen cuando existen diferencias en las mismas líneas de código de los archivos. Ya sea que un compañero modifico la misma línea de un archivo CSS que tú y tienen diferentes cosas. 
            <br> Los conflictos son fáciles de solucionar y no debe generarte caos ni confusión. La consola de GIT te indicará el estatus del merge que intentaste realizar. <br> <b>Auto-merging archivo.extension</b> indicará un merge correcto y <b>CONFLICT (Content) archivo.extension</b> indicará un conflicto.
            <br><br>
            <img src="img/screenshot_error_merge.png" alt="error de consola al realizar merge" />
            <br><br>
            Al revisar nuestro archivo en conflicto, encontraremos algo muy peculiar en el, GIT nos muestra exactamente cual fue la línea en conflictos y cuales son las diferencias entre nuestra rama actual y la que queremos obtener. Así se debe ver al usar el bloc de notas:
            <br><br>
            <img src="img/screenshot_error_merge_blocNotas.png" alt="diferencias de código bloc de notas" />
            <br><br>
            Debemos elegir entre el código que deseamos dejar en el repositorio y para esto, debemos comunicarnos con la persona que escribió el código (si es que estamos trabajando colaborativamente con alguien más) para decidir que código debe irse a la versión del merge. Posterior a este paso, se deben comentar la línea de <b>"<<<<"</b>, las de <b>"===="</b>  y las de <b>">>>>"</b>  junto con el código que no irá al repositorio.
            <br>
            Se deben guardar los cambios en el archivo y realizar un nuevo <b>git add .</b> además de un <b>git commit -m "Comentario relacionado con la solución del conflicto en el merge"</b>
            <br><br>
            <b>Adicional:</b> Si usas VSCode, podrás ver que el te da una sugerencia de que hacer con los cambios:
            <br><br>
            <img src="img/screenshot_error_merge_code.png" alt="diferencias de código VSCode" />
            <br><br>
            Si eliges <b>Accept Current Change</b> estarás dejando los cambios de la rama actual, en cambio, si elgies <b>Accept Incoming Change</b> estarás obteniendo los cambios de la rama desde la cual estás obteniendo los cambios.
            </li>
        </ul>
    </ul>
    <br>

    <h1>Repositorios remotos - GitHub</h1>
    <p>Conoceremos como poder conectar nuestro repositorio local con algún repositorio remoto, subir nuestros cambios a dicho repositorio, obtener los cambios desde el repositorio y mucho más.</p>
    <p>Para este caso de prueba utilizaremos el repositorio remoto más conocido del mundo, <a href="https://github.com/">GitHub</a>.</p>
    <ol>
        <li>Primero, debemos crearnos una cuenta en GitHub y crear un nuevo repositorio. Preferiblemente, debemos crear el archivo README ya que a través de el podremos indicarle a otros desarrolladores de que va nuestro código.</li><br>
        <li>Luego de crear el repositorio, Github nos dará la url del mismo, esta la utilizaremos para agregar este origen remoto desde nuestro repositorio local. Se debe copiar la ruta HTTPS que github nos dió: <br><br> <img src="img/url_repo_github.png" alt="url de nuestro repositorio remoto"><br><br></li>
        <li>Usar el comando <b>git remote add origin urlRepositorioRemoto</b> con esto, estaremos agregando la referencia del repositorio remoto a nuestro repositorio en local. Posterior a esto, la consola de git no arrojará ningún mensaje, pero si usamos el comando <b>git remove -v</b> podremos visualizar el repositorio remoto al que hacemos referencia actualmente. 
        <br><br>
        <img src="img/git_remote_v.png" alt="git remote -v para ver la referencia del repositorio remoto">
        <br><br>
        Te dejo la url de este mismo repositorio para que puedas probar: <b>https://github.com/avasquez-ve/gitCommands.git</b></li><br>
        <li>Como ya tenemos la referencia del repositorio remoto, ahora debemos obtener la historia que se encuentre en dicho repositorio, esta acción se debe realizar siempre antes de enviar los cambios desde el repositorio local. <br><br> Si el repositorio remoto es diferente a nuestro repositorio local, es probable que Git nos de un warning con el mensaje <b>"refusing to merge unrelated histories"</b> esto quiere decir que no puede hacer la fusión debido a que las historias de los dos repositorios son diferentes. Para forzar esta acción y poder obtener la historia del repositorio remoto debemos usar el comando <b>git pull origin master --allow-unrelated-histories</b> para permitir unir ambas historias.</li>
        <br><br>
        <img src="img/git_pull_origin_master.png" alt="git pull origin master, mensajes de advertencia">
        <br><br>

        <li>Con el comando <b>ls -al</b> podremos ver el archivo <b>README</b> creado desde GitHub. Y al ejecutar <b>git log</b> también veremos el commit hecho en GitHub para dicho archivo. 
        <br><br>
        <img src="img/ls-al.png" alt="comando ls -al. Usado para visualizar en forma de lista los archivos visibles y ocultos de un directorio">
        <br><br>
        </li>
        <li>Ahora, para subir los cambios locales al repositorio, debemos usar el comando <b>git push origin master</b>, con esto, ya nuestros cambios locales estarán dentro del repositorio remoto. Recordar siempre que este comando lo debemos ejecutar desde la <b>rama master</b> para no generar conflictos.</li>
        <br><br>
        <img src="img/git_push_origin_master.png" alt="comando git push origin master. Usado para subir los cambios hacia un repositorio remoto">
        <br><br>
        <p>Así quedó nuestro repositorio remoto en GitHub luego de agregar los cambios desde el repositorio local</p>
        <br>
        <img src="img/proyectoGitHub.png" alt="repositorio en GitHub">
        <br>
    </ol>

    <h1>Configurar tus llaves SSH en local</h1>
    <p>Aprenderemos como usar las llaves SSH para conectarnos a GitHub usando SSH y dejar a un lado HTTPS</p>
    <p>Para hacer nuestra conexión aún más segura, podemos usar llaves encriptadas, con las cuales enviamos nuestros datos cifrados. Dichos datos solo podrán ser decifrados con una llave pública que compartiremos con GitHub.</p>
    <ol>
        <li><b>Primer paso:</b> Generar las llaves SSH con el comando <br> <b>ssh-keygen -t rsa -b 4096 -C "tu@email.com"</b> <br> debemos usar el mismo email que usamos para Github. Tomar en cuenta que luego de apretar enter, nos va a sugerir agregarle una contraseña a dicha llave para hacerla aún más segura. Este paso es opcional, si no queremos agregarle una contraseña solo aprietas ENTER.</li><br>
        <li><b>Las llaves se guardaran</b> en una carpeta oculta llamada .ssh donde tendremos la llave pública <b>id_rsa.pub</b> y la privada <b>id_rsa</b> NOTA: La llave privada <b>jamás</b> se debe compartir con nadie ni con ningún otro dispositivo.</li><br>
        <li><b>Segundo paso:</b> para terminar de configurar las claves, debemos comprobar que el servidor se encuentre activo, para esto usar el comando <br> <b>eval $(ssh-agent -s)</b> <br> lo cual nos debería retornar un mensaje <b>Agent pid numeroAleatorio</b></li><br>
        <li><b>Tercer y último paso:</b> ahora, solo debemos agregar al servidor nuestra llave privada, para esto, usar el comando <br> <b>ssh-add ruta-donde-guardaste-tu-llave-privada</b> <br> Y listo, ya tendremos configurada nuestra llave privada para poder conectarnos a través de SSH con GitHub</li><br>
    </ol>

    <h1>Conectarnos a Github a través de SSH</h1>
    <p>Luego de haber creado y configurado nuestra llave privada. Debemos configurar nuestra llave pública (la única que podemos compartir) con Github. Es importante tener en cuenta que debemos realizar los pasos anteriores, de lo contrario, no podremos continuar con este paso.</p>
    <ol>
        <li><B>Como primer paso:</B> debemos agregar nuestra llave pública a nuestra cuenta de Github. Para eso debemos copiar el contenido de nuestra llave publica, ubicada en el archivo <b>id_rsa.pub</b></li><br>
        <li><b>El segundo paso es:</b> Ingresar en nuestra cuenta de Github y dirigirnos a la configuración y posteriormente a la gestion de KEYS SSH <br> url: <a href="https://github.com/settings/keys">https://github.com/settings/keys</a><br> Debemos hacer click en  <b>New SSH Key</b> <br> <img src="img/crear_nueva_key_ssh.png" alt="boton crear nueva key ssh"><br> y luego agregar como título, el pc que tendrá asignado dicha key publica, esto es para poder identificarlo, ya que podemos tener varios equipos conectados por SSH a nuestros repositorios. Al finalizar, hacer click en <b>Add SSH KEY</b><br><img src="img/agregando_key.png" alt="agregando key ssh"><br> </li><br>
        <li>Ahora podremos ver que nuestra key SSH se agregó correctamente <br><img src="img/identificador_ssh_key.png" alt="ver key agregada"><br></li><br>

        <li><b>Como siguiente paso</b>, debemos configurar nuestro repositorio local para dejar de usar HTTPS y empezar a usar SSH con nuestras nuevas keys. Para esto, debemos ir a nuestro repositorio y ejecutar el comando <br> <b>git remote set-url origin url-ssh-del-repositorio-en-github</b> <br> Con esto estaremos cambiando la url del repositorio en github. Podemos comprobar la nueva url usando <b>git remove -v</b></li><b></b>
        <li>Ahora puedes hacer un <b>git pull origin master</b> confirmar los mensajes, realizar cambios en tu repositorio local y hacer un <b>git push origin master</b></li>
    </ol>

    <h1>Tags y versiones en Git y GitHub</h1>
    <p>Los tags nos permiten asignar versiones a los commits con cambios más importantes o significativos en nuestro proyecto. A continuación, se presentan los comandos para trabajar con las etiquetas:</p>
    <ul>
        <li><b>Crear un tag: </b> antes de crear un tag se debe elegir el commit el cual queremos identificar, para esto, podemos hacer un: <br><br><b>git log --all --graph --decorate --oneline</b> o un <b>git log --all --oneline</b> y copiar el id del commit. <br><br> Se usan los comandos anteriores para poder obtener el id más corto. <br> Luego, ejecutamos el comando para crear el tag <b>git tag -a nombreDelTag -m "Comentario asociado al tag" idDelCommit</b></li><br>
        <li><b>Visualizar tags creados:</b> Para visualizar los tags que tenemos creados podemos usar los comandos <b>git tag</b> o <b>git show-ref --tags</b> con el primero, solo veremos el nombre del tag y con el segundo, podremos ver el commit generado al crear el tag y la ubicacion.</li><br>
        <li><b>Enviar tags a un repositorio remoto: </b>Para publicar nuestros tags se debe usar el comando <b>git push origin --tags</b> si te das cuenta, se hace diferente a publicar un commit común.</li>
        <li><b>Eliminar tags:</b> Los tags son publicados en Github como releases, versiones estables de nuestro código que deberían funcionar sin problemas. Si llegas a publicar un tag por equivocación, puedes borrarlo con los siguientes dos comandos: <br><br> <b>git tag -d nombreDelTag</b> con esto estaremos borrando el tag en el repositorio local. Para eliminarlo del repositorio remoto se debe usar <b>git push origin :refs/tags/nombreDelTag</b></li>
    </ul>



    <script>
        document.addEventListener("DOMContentLoaded", function (e) {
            var date = new Date();
            var hours = date.getHours();
            if (hours >= 20 || hours <= 7) {
                setTimeout(function() {
                    if (confirm("Al parecer ya se hizo de noche, ¿deseas activar el modo nocturno?")) {
                        document.body.style.backgroundColor = '#282A35';
                        document.body.style.color = '#FFFFFF';
                        btnVision.innerText = "Cambiar a versión normal";
                    }
                },4000);
            }
        });

        var btnVision = document.getElementById("changeWeb");
        btnVision.addEventListener("click", function (e) {
            var txtBtnVision = btnVision.innerText;

            if (txtBtnVision == "Cambiar a versión nocturna") {
                document.body.style.backgroundColor = '#282A35';
                document.body.style.color = '#FFFFFF';
                btnVision.innerText = "Cambiar a versión normal";
            } else {
                document.body.style.backgroundColor = '#FFFFFF';
                document.body.style.color = '#000000';
                btnVision.innerText = "Cambiar a versión nocturna";
            }
        });
    </script>
</body>
</html>